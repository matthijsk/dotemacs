#+TITLE: Emacs Configuration

* Emacs settings
** Packages and use-package
This configuration file is loaded using ~(org-babel-load-file)~. To ensure
org-mode is properly initialized before loading this file ~package-archives~
settings and the call to ~(package-initialize)~ are done in =[[file:init.el][init.el]]=.

Packages are installed and configured using ~use-package~.

** Diminish
[[https://github.com/myrjola/diminish.el][Diminish]] can be used as part of =use-package= to hide minor mode strings from
the modeline.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :pin melpa-stable
    :ensure t)
#+END_SRC

** General settings
General Emacs settings relating to fonts, themes, keybindings, etc.

Set default coding system.
#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
#+END_SRC

Disable automatic backups. See
http://ergoemacs.org/emacs/emacs_set_backup_into_a_directory.html.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+END_SRC

Display the scratch buffer when starting up.
#+BEGIN_SRC emacs-lisp
  (setq initial-buffer-choice t)
#+END_SRC

Start Emacs as server for emacsclient processes.
#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC

Ask for confirmation when leaving Emacs.
#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'yes-or-no-p)
#+END_SRC

Allow for basic paging in emacs shells.
#+BEGIN_SRC emacs-lisp
  (setenv "PAGER" "/bin/cat")
#+END_SRC

Increase warning limit to 100 MB for large files.
#+BEGIN_SRC emacs-lisp
  (setq large-file-warning-threshold (* 100 1024 1024))
#+END_SRC

Fix slow redisplay when certain special characters are on screen.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

Set fill-column to 80 characters. Use ~setq-default~ because fill-column becomes
buffer-local when set.
#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
#+END_SRC

Also end sentences with a period and a single space. This affects filling and
various commands such as ~(backward-sentence)~ and ~(forward-sentence)~.
#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

** Scrolling
Settings related to scrolling buffers.

Provide some context by have the cursor offset from the top and the bottom of
the buffer by three lines.
#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 3)
#+END_SRC

Scroll by one line when reaching bottom of buffer instead of recentering the
buffer.
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively most-positive-fixnum)
#+END_SRC

Don't scroll faster when the mouse wheel is turned faster. Also, use a fixed
scroll amount of three lines.
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-progressive-speed nil)
  (setq mouse-wheel-scroll-amount (quote (3 ((shift) . 1) ((control)))))
#+END_SRC

** User interface
Set the Consolas font when running on Windows.
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'windows-nt)
    (let ((my-font "-outline-Consolas-normal-normal-normal-mono-*-*-*-*-c-*-iso8859-1"))
      (set-face-attribute 'default nil :font my-font)
      (set-frame-font my-font nil t)))
#+END_SRC

Set the [[https://github.com/nashamri/spacemacs-theme][spacemacs]] theme when a graphical display is available. Pretty neat.
#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (use-package spacemacs-common
      :ensure spacemacs-theme

      :custom
      (spacemacs-theme-org-bold t)
      (spacemacs-theme-org-height nil)

      :config
      (load-theme 'spacemacs-dark)))
#+END_SRC

Disable the tool bar, the menu bar and the scroll bars.
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (when (featurep 'scroll-bar)
    (set-scroll-bar-mode nil))
#+END_SRC

Default to displaying line numbers as relative.
#+BEGIN_SRC emacs-lisp
  (setq display-line-numbers-type 'relative)
#+END_SRC

Display time as 24h.
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
#+END_SRC

Use a visible bell.
#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

Don't blink the cursor.
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
#+END_SRC

** Key bindings
Reload ('revert') a buffer with =F5= without asking for confirmation, and
preserve all modes.
#+BEGIN_SRC emacs-lisp
  (defun my-revert-buffer ()
    "Revert a buffer without asking for confirmation and preserve all modes."
    (interactive)
    (revert-buffer nil t t))

  (global-set-key (kbd "<f5>") 'my-revert-buffer)
#+END_SRC

Load alternate file with =F6= (useful for switching .c and .h).
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f6>") 'ff-find-other-file)
#+END_SRC

Exhibit expected X clipboard behaviour (yank with middle mouse button).
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<mouse-2>") 'x-clipboard-yank)
  (setq-default x-select-enable-primary t)
#+END_SRC

Bind mouse buttons to Info-mode and help-mode navigation.
#+BEGIN_SRC emacs-lisp
  (define-key Info-mode-map (kbd "<mouse-4>") 'Info-history-back)
  (define-key Info-mode-map (kbd "<mouse-5>") 'Info-history-forward)
  (define-key Info-mode-map (kbd "<mouse-8>") 'Info-history-back)
  (define-key Info-mode-map (kbd "<mouse-9>") 'Info-history-forward)

  (define-key help-mode-map (kbd "<mouse-4>") 'help-go-back)
  (define-key help-mode-map (kbd "<mouse-5>") 'help-go-forward)
  (define-key help-mode-map (kbd "<mouse-8>") 'help-go-back)
  (define-key help-mode-map (kbd "<mouse-9>") 'help-go-forward)
#+END_SRC

Disable =C-h h=, which is bound to ~view-hello-file~. I sometimes press this
accidentally. As opening the HELLO file takes long enough to be annoying disable
this binding here.
#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-h h"))
#+END_SRC

Some sane bindings for making and deleting frames (an Emacs 'frame' is a
'window' in modern terms). =C-x 5 2= and =C-x 5 0= are just...too much. So
instead use =C-c n= for a new frame and =C-c x= (and =M-<f4>=) to delete the
frame.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c n") 'make-frame-command)

  (global-set-key (kbd "C-c x") 'delete-frame)
  (global-set-key (kbd "M-<f4>") 'delete-frame)
#+END_SRC

When I call kill-buffer I pretty much always mean to kill the current
buffer. The default functionality is to prompt for a buffer name. Instead, I
want the buffer to be killed immediately. Inspiration:
http://pragmaticemacs.com/emacs/dont-kill-buffer-kill-this-buffer-instead/.
#+BEGIN_SRC emacs-lisp
  (defun my-kill-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'my-kill-buffer)
#+END_SRC

Bind =hippie-expand= to =M-/=.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

** Enable disabled commands
Some commands are disabled by default, enable these so Emacs doesn't
ask for confirmation every time the command is executed.

Allow narrowing.
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

Allow upcasing and lowercasing of regions.
#+BEGIN_SRC emacs-lisp
  (put 'upcase-region   'disabled nil)
  (put 'downcase-region 'disabled nil)
#+END_SRC

** Programming settings
Settings for setting up a programming environment.

Enable eldoc-mode for elisp buffers.
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

Highlight matching parentheses.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

Customize comment-dwim so it does exactly what I want it to do:
- If a region is active, comment it if not commented or uncomment if commented.
- Otherwise, comment or uncomment the current line and move to the next line.
Seriously, Emacs is awesome. I love this kind of customization power.
#+BEGIN_SRC emacs-lisp
  (defun my-comment-dwim (arg)
    "Call the comment command you want (Do What I Mean).
  If the region is active and `transient-mark-mode' is on, call
  `comment-region' (unless it only consists of comments, in which
  case it calls `uncomment-region').  Else, it calls
  `comment-line'.  Custom implementation derived from
  `comment-dwim'. The difference is that the original function
  appends a comment to a line while this function comments the
  line itself."
    (interactive "*P")
    (comment-normalize-vars)
    (if (use-region-p)
        (comment-or-uncomment-region (region-beginning) (region-end) arg)
      (comment-line 1)))
#+END_SRC

Autoscroll compilation window and stop on first error.
#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output 'first-error)
#+END_SRC

Set c and sh indentation to 2, and never indent with tabs.
#+BEGIN_SRC emacs-lisp
  (setq c-default-style "linux"
        c-basic-offset 2)

  (setq-default indent-tabs-mode nil)

  (setq sh-basic-offset 2)
#+END_SRC

Set some modes for specific file types.
- Set ~xml-mode~ when loading =cbproj= and =groupproj= files.
- Set ~c++-mode~ when loading =.rc= and =.rh= files.
- Set ~c++-mode~ when loading =.h= files. All I do is c++ all day.
- Set ~conf-mode~ when loading a Doxygen configuration file.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.cbproj\\'" . xml-mode))
  (add-to-list 'auto-mode-alist '("\\.groupproj\\'" . xml-mode))

  (add-to-list 'auto-mode-alist '("\\.rh\\'" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.rc\\'" . c++-mode))

  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))

  (add-to-list 'auto-mode-alist '("Doxyfile" . conf-mode))
#+END_SRC

Highlight TODO keywords in all programming modes using the =org-todo=
face.
#+BEGIN_SRC emacs-lisp
  (defun my-prog-mode-todo-font-lock ()
    "Font lock for \"TODO\" strings in prog-mode major modes.
  Sets face to `org-todo'."
    (font-lock-add-keywords nil
                            '(("\\<\\(TODO\\).*:" 1 'org-todo prepend))))

  (add-hook 'prog-mode-hook 'my-prog-mode-todo-font-lock)
#+END_SRC

** Default search function
Just a wrapper around whatever search function strikes my fancy
today. This makes it easier to change functionality without the tedium
of having to rebind all keys.
#+BEGIN_SRC emacs-lisp
  (defun my-search ()
    (interactive)
    (swiper-helm (word-at-point)))
    ;; (swiper))
    ;; (helm-occur))
    ;; (helm-swoop))

  (global-set-key (kbd "C-s") 'my-search)
#+END_SRC

** Find configuration files
This configuration file is written in =org-mode=. The file is
tangled into an =.el= file using an ~(org-babel-load-file)~ call in
=init.el= when Emacs starts.

These functions enable quick access to the configuration file and the
Emacs init file.
#+BEGIN_SRC emacs-lisp
  (defun my-find-configuration-file ()
    "Opens the configuration file in a new buffer.
  Opens the configuration file that is loaded by
  `user-init-file'. Use `my-find-init-file' to open
  `user-init-file'."
    (interactive)
    (find-file (concat user-emacs-directory "configuration.org")))

  (defun my-find-init-file ()
    "Opens `user-init-file' in a new buffer."
    (interactive)
    (find-file user-init-file))
#+END_SRC

** Spell check
Use hunspell as spell checker if it is available. Neato. Also enable flyspell
for text mode.
#+BEGIN_SRC emacs-lisp
  (when (executable-find "hunspell")
    (setq ispell-program-name "hunspell")
    (setq ispell-really-hunspell t)
    (add-hook 'text-mode-hook 'flyspell-mode))
#+END_SRC

** IBuffer
Remap =C-x C-b= to ~ibuffer~ instead of the default.

Use a human-readable Size column for =ibuffer=. Taken from [[https://www.emacswiki.org/emacs/IbufferMode#toc12][Emacs Wiki]].
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind (("C-x C-b" . ibuffer))
    :config
    ;; Use human readable Size column instead of original one.
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 100000) (format "%7.0fk" (/ (buffer-size) 1000.0)))
       ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size)))))

    ;; Modify the default ibuffer-formats.
    (setq ibuffer-formats
          '((mark modified read-only " "
                  (name 18 18 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  filename-and-process))))
#+END_SRC

** Ediff
Always split windows horizontally when running ediff. This is more comfortable
to me on modern screens.
#+BEGIN_SRC emacs-lisp
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-merge-split-window-function 'split-window-horizontally)
#+END_SRC

** Eww
Set eww (shr) frame width.
#+BEGIN_SRC emacs-lisp
  (setq shr-width 80)
#+END_SRC

** Eshell
Initialize and set up eshell completion.
#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook (lambda ()
                                (eshell-cmpl-initialize)
                                (setq eshell-cmpl-cycle-completions nil)))
#+END_SRC

** Dired
Use human-readable sizes in dired listings.
#+begin_src emacs-lisp
  (setq dired-listing-switches "-alh")
#+end_src

* Smart mode line
Use [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] as a mode-line. Nothing too fancy but offers more
than the default, such as abbreviating =.emacs.d= to =:ED:=.
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :ensure t
    :pin melpa-stable

    :config
    (setq sml/theme 'automatic)
    (sml/setup))
#+END_SRC

* Default text scale
By default, scaling in Emacs (using =text-scale-adjust=) only scales
the text in the buffer, but not in the modeline or the
mini-buffer. The package [[https://github.com/purcell/default-text-scale][default-text-scale]] enables Emacs-wide
scaling.
#+BEGIN_SRC emacs-lisp
  (use-package default-text-scale
    :ensure t
    :pin melpa-stable
    :bind (("C-M-="       . default-text-scale-increase)
           ("C-<mouse-4>" . default-text-scale-increase)
           ("C-M--"       . default-text-scale-decrease)
           ("C-<mouse-5>" . default-text-scale-decrease)))
#+END_SRC

* Evil
I used to be a Vim user. To be honest, I guess I still am. Else why
commit the sacrilege of using Vim bindings in Emacs? The modal editing
model of Vim works really well for me, and [[https://github.com/emacs-evil/evil][Evil]] is hands down the best
Vim emulator for Emacs. This gives me the best of both worlds: the
modal editing of Vim combined with the extensibility of Emacs.
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :pin melpa-stable
    :demand t
    :diminish undo-tree-mode
    :bind (:map evil-normal-state-map
                ("C-s"     . save-buffer)
                ("C-/"     . my-comment-dwim)
                ("C-f"     . my-search)

           :map evil-motion-state-map
                ("C-f" . my-search)

           :map evil-insert-state-map
                ("C-s" . save-buffer)
           )
    :init
    (setq evil-want-C-u-scroll t)
    (setq evil-symbol-word-search t)
    (setq evil-shift-width 2)

    :config
    ;; Ensure the yank register (on Windows, at least) is not overwritten when
    ;; performing a visual selection.
    ;; See https://emacs.stackexchange.com/questions/9344/pasting-in-evil-mode-when-theres-an-active-selection-copies-the-selection
    (fset 'evil-visual-update-x-selection 'ignore)

    (evil-define-key 'motion Man-mode-map (kbd "RET") 'man-follow)

    ;; Jump to tag and recenter.
    (advice-add 'evil-jump-to-tag     :after 'evil-scroll-line-to-center)
    (advice-add 'evil-jump-backward   :after 'evil-scroll-line-to-center)
    (advice-add 'evil-jump-forward    :after 'evil-scroll-line-to-center)
    (advice-add 'evil-search-next     :after 'evil-scroll-line-to-center)
    (advice-add 'evil-search-previous :after 'evil-scroll-line-to-center)

    ;; Ex commands.
    (evil-ex-define-cmd "A"  'ff-find-other-file)
    (evil-ex-define-cmd "ls" 'ibuffer)

    ;; Ensure Emacs bindings for RET and SPC are available in motion state.
    ;; https://www.emacswiki.org/emacs/Evil#toc12
    (defun my-move-key (keymap-from keymap-to key)
      "Moves key binding from one keymap to another, deleting from the old location. "
      (define-key keymap-to key (lookup-key keymap-from key))
      (define-key keymap-from key nil))
    (my-move-key evil-motion-state-map evil-normal-state-map (kbd "RET"))
    (my-move-key evil-motion-state-map evil-normal-state-map " ")

    (defun my-evil-c-end-of-statement ()
      "Go to the end of the innermost C statement.
  Calls `c-end-of-statement' after incrementing `point' by 1.
  Enables use of of this function while in evil normal state. See
  Info node `(evil)Modes and states'."
      (interactive)
      (evil-goto-char (+ 1 (point)))
      (c-end-of-statement))

    (evil-define-key 'normal c-mode-map (kbd "M-e") 'my-evil-c-end-of-statement)
    (evil-define-key 'normal c++-mode-map (kbd "M-e") 'my-evil-c-end-of-statement)

    ;; Set custom evil state when in these modes.
    (add-hook 'with-editor-mode-hook 'evil-normal-state)

    (evil-set-initial-state 'shell-mode            'emacs)
    (evil-set-initial-state 'eshell-mode           'emacs)
    (evil-set-initial-state 'image-mode            'emacs)
    (evil-set-initial-state 'dired-mode            'emacs)
    (evil-set-initial-state 'messages-buffer-mode  'motion)
    (evil-set-initial-state 'eww-mode              'motion)
    (evil-set-initial-state 'eww-buffers-mode      'motion)
    (evil-set-initial-state 'elisp-refs-mode       'motion))
#+END_SRC

* Evil-leader
Configure [[https://github.com/cofi/evil-leader][evil-leader]] for leader keys with Evil.
#+BEGIN_SRC emacs-lisp
  (use-package evil-leader
    :ensure t
    :pin melpa-stable
    :after evil

    :config
    (evil-leader/set-leader ",")
    (evil-leader/set-key "e"   'my-find-configuration-file
                         "i"   'my-find-init-file

                          "sh"  'eshell

                          "wc"  'evil-window-delete
                          "x0"  'delete-window

                          "ww"  'evil-window-next
                          "xo"  'other-window

                          "wo"  'delete-other-windows
                          "x1"  'delete-other-windows

                          "ws"  'evil-window-split
                          "x2"  'split-window-below

                          "wv"  'evil-window-vsplit
                          "x3"  'split-window-right

                          "wh"  'evil-window-left
                          "wj"  'evil-window-down
                          "wk"  'evil-window-up
                          "wl"  'evil-window-right

                          "xk"  'my-kill-buffer
                          "rb"  'revert-buffer
                          "x#"  'server-edit
                          "n"   'server-edit
                          "xc"  'save-buffers-kill-terminal

                          "l"   'whitespace-mode
                          "hl"  'hl-line-mode
                          "rl"  'display-line-numbers-mode

                          "m"   'compile
                          "c"   'compile)

    ;; Enable evil leader.
    (global-evil-leader-mode)

    ;; Start evil.
    (evil-mode))
#+END_SRC

* Dash
Ensure dash ("A modern list library for Emacs") is installed. It is used by many
packages.
#+BEGIN_SRC emacs-lisp
  (use-package dash
    :ensure t
    :pin melpa-stable)
#+END_SRC

* Helm
Use [[https://emacs-helm.github.io/helm/][Helm]] for completion and narrowing.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :diminish helm-mode
    :ensure t
    :pin melpa-stable
    :bind (("M-x"     . helm-M-x)
           ("C-x b"   . helm-mini)
           ("C-x C-f" . helm-find-files)
           ("C-x C-h" . helm-resume-existing)
           ("C-x r l" . helm-bookmarks)

           :map helm-map ;; Use <C-tab> and <C-S-tab> to navigate helm buffers.
           ("<C-tab>"   . helm-next-line)
           ("<C-S-tab>" . helm-previous-line)

           :map evil-normal-state-map
           ("<SPC>" . helm-mini)

           :map evil-leader--default-map
           ("b"  . helm-mini)
           ("xf" . helm-find-files)
           ("hb" . helm-bookmarks)
           ("hs" . helm-semantic-or-imenu)
           ("xh" . helm-resume-existing))

    :config
    (defun helm-resume-existing ()
      "Resume previous helm session with prefix to choose among existing helm buffers."
      (interactive)
      (helm-resume t))

    (helm-mode 1)

    (setq helm-buffer-max-length nil)
    (setq helm-split-window-inside-p t)

    (add-hook 'eshell-mode-hook (lambda ()
                                  (define-key eshell-mode-map (kbd "M-p") 'helm-eshell-history)))

    (evil-leader/set-key-for-mode 'org-mode "hs" 'helm-org-in-buffer-headings)

    (advice-add 'helm-org-in-buffer-headings
                :after
                (lambda ()
                  "Move selected line to top when helm exits successfully."
                  (when (= helm-exit-status 0)
                    (recenter-top-bottom 0)))))
#+END_SRC

* Projectile
Use [[https://github.com/bbatsov/projectile][Projectile]] for project interaction. Works really well with
Git repositories for quick navigation.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :pin melpa-stable
    :bind-keymap ("C-c p" . projectile-command-map)
    :bind (:map projectile-mode-map
                ("<f9>" . projectile-run-project)
                ("C-<f9>" . projectile-compile-project)
                ("M-<f9>" . projectile-test-project))

    :init
    (add-hook 'c-mode-hook     'projectile-mode)
    (add-hook 'c++-mode-hook   'projectile-mode)
    (add-hook 'cmake-mode-hook 'projectile-mode)

    :config
    (projectile-mode 1)

    (setq projectile-indexing-method 'hybrid)
    (setq projectile-enable-caching t)
    (setq projectile-use-git-grep t))
#+END_SRC

* Helm-projectile
Combine Helm and Projectile for awesome project navigation with
awesome completion.
#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :ensure t
    :pin melpa-stable
    :after dash helm projectile
    :bind 
    (:map projectile-command-map
          ("p" . helm-projectile-switch-project)
          :map evil-leader--default-map
          ("pf"  . helm-projectile-find-file)
          ("psg" . helm-projectile-grep)
          ("pa"  . helm-projectile-find-other-file))

    :init
    (setq helm-projectile-fuzzy-match nil)
    (setq projectile-switch-project-action 'helm-projectile)

    :config
    (helm-projectile-on))
#+END_SRC

* Outline-magic
The package outline-magic provides ~(outline-cycle)~, which functions similar to
~(org-cycle)~. This is useful for the odd occasion when I run into an
outline-mode buffer.
#+begin_src emacs-lisp
  (use-package outline-magic
    :bind (:map outline-mode-map
                ([tab] . outline-cycle)))
#+end_src

* Org mode
[[https://orgmode.org/][Org-mode]] is, for me, a compelling reason to use Emacs. At the very
least, it is useful for note taking and managing work using TODO
lists. More recently, I have also started using org-mode to keep track
of time spent on individual tasks, in addition to simply keeping track
of the total amount of time spent at work during a day, which I have
been doing for some years now.

The ~(my-clock-in)~ and ~(my-clock-in-monday)~ functions are used for
keeping track of time spent at work.
#+BEGIN_SRC emacs-lisp
  ;; Org html export requires htmlize.
  (use-package htmlize
    :ensure t
    :pin melpa-stable
    :defer t)

  (use-package org
    :ensure t
    :pin gnu
    ;; Global key bindings.
    :bind (("\C-cl" . org-store-link)
           ("\C-ca" . org-agenda)
           ("\C-cc" . org-capture)
           ("\C-cb" . org-switchb)
           ("\C-ci" . my-clock-in)
           ("\C-cj" . org-clock-goto)
           ("\C-co" . org-clock-out))
    :init
    (setq org-todo-keywords
          '((sequence "TODO" "IN PROGRESS" "REVIEW" "DONE" )))

    ;; Set org-agenda-files to file with list containing all agenda files.
    (setq org-agenda-files (concat org-directory "/org-agenda-files.org"))

    :config
    (defun my-clock-in-monday ()
      "Create a heading \"Week <WEEK-NUMBER>\" above the current heading,
  then calls `my-clock-in' with argument MONDAY set to t. The week
  number is the ISO week number."
      (interactive)
      (if (not (org-at-heading-p))
          (user-error "Not at a heading"))
      (beginning-of-line)
      (org-insert-heading)
      (insert (format "Week %s" (org-days-to-iso-week (org-today))))
      (my-clock-in t))

    (defun my-clock-in (&optional monday)
      "Create a heading after the current heading and clock in using
  `org-clock-in'. The heading has the format \"[timestamp]\", where timestamp is
  an inactive org timestamp.

  If the optional argument MONDAY is t the heading is also
  demoted by one level."
      (interactive)
      (if (not (org-at-heading-p))
          (user-error "Not at a heading"))
      (org-insert-heading-after-current)
      (org-insert-time-stamp (current-time) nil t)
      (if monday
          (org-demote))
      (org-clock-in))

    (org-clock-persistence-insinuate)

    (setq org-clock-clocktable-default-properties
          '(:maxlevel 3 :scope agenda :block yesterday :narrow 120!))

    ;; Show total amount of hours and minutes, instead of formatting as "d hh:mm".
    (setq org-duration-format '((special . h:mm)))

    ;; Set all agenda files as refile targets.
    (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))

    ;; Enable refiling to the top level of an org file.
    (setq org-refile-use-outline-path 'file)

    ;; Org mode babel language support.
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (shell . t)
       (C . t)))

    ;; Do not interpret "_" and "^" for sub and superscript when
    ;; exporting.
    (setq org-export-with-sub-superscripts nil)

    ;; When in org-mode, use expected org-mode tab behaviour when in
    ;; Normal and Insert state. Set jump keys to navigate org links and
    ;; the mark ring.
    (evil-define-key 'normal org-mode-map
      [tab] 'org-cycle
      (kbd "C-]") 'org-open-at-point
      (kbd "C-o") 'org-mark-ring-goto)

    (evil-define-key 'insert org-mode-map [tab] 'org-cycle)

    ;; Don't complete in steps, works well with narrowing frameworks such as Helm.
    (setq org-outline-path-complete-in-steps nil)

    ;; Save the running clock when Emacs exits.
    (setq org-clock-persist 'clock)

    ;; Flushright tags to column 100.
    (setq org-tags-column -100))
#+END_SRC

* Magit
Magit is another (alongside org-mode) compelling reason to use Emacs. Seriously,
it is the best keyboard driven Git interface I know of. It also integrates very
nicely into Emacs. Interactive rebasing, cherry-picking or running git blame on
a single file are a breeze with Magit.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :pin melpa-stable
    :defer t
    :bind (:map evil-leader--default-map
                ("st" . magit-staging)
                ("f"  . magit-file-popup))

    :init
    (evil-set-initial-state 'magit-staging-mode 'emacs)

    :config
    ;; Don't show tags when displaying refs.
    (remove-hook 'magit-refs-sections-hook 'magit-insert-tags)

    ;; Don't show diff when committing (use C-c C-d to show diff anyway).
    (remove-hook 'server-switch-hook 'magit-commit-diff)

    ;; Improve staging performance on Windows.
    ;; See https://github.com/magit/magit/issues/2395
    (define-derived-mode magit-staging-mode magit-status-mode "Magit staging"
      "Mode for showing staged and unstaged changes."
      :group 'magit-status)

    (defun magit-staging-refresh-buffer ()
      (magit-insert-section (status)
                            (magit-insert-untracked-files)
                            (magit-insert-unstaged-changes)
                            (magit-insert-staged-changes)))

    (defun magit-staging ()
      (interactive)
      (magit-mode-setup #'magit-staging-mode))

    (magit-define-popup-switch 'magit-log-popup ?f "first parent" "--first-parent")

    (evil-define-key 'normal magit-blame-mode-map (kbd "q") 'magit-blame-quit)

    (setq magit-refresh-verbose t))
#+END_SRC

* CMake mode
Make sure cmake-mode is installed. Useful for syntax highlighting of cmake files
and for the integrated help.
#+BEGIN_SRC emacs-lisp
  (use-package cmake-mode
    :ensure t
    :defer t)
#+END_SRC

* Ninja mode
Syntax highlighting for ninja build files.
#+BEGIN_SRC emacs-lisp
  (use-package ninja-mode
    :ensure t
    :pin melpa-stable
    :defer t)
#+END_SRC

* GTAGS / GNU Global

#+BEGIN_SRC emacs-lisp
  ;; Force treating of .h files as C++ source.
  (setenv "GTAGSFORCECPP" "true")

  (add-to-list 'auto-mode-alist '("\\.globalrc" . conf-mode))
#+END_SRC

* Helm gtags

#+BEGIN_SRC emacs-lisp
  (use-package helm-gtags
    :ensure t
    :pin melpa-stable
    :defer t
    :diminish helm-gtags-mode

    :init
    (add-hook 'c-mode-hook   'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)

    :config
    (setq helm-gtags-path-style 'absolute)
    (setq helm-gtags-use-input-at-cursor t)
    (setq helm-gtags-auto-update t)
    (setq helm-gtags-pulse-at-cursor t)

    (evil-define-key 'normal c-mode-map   (kbd "C-]") 'helm-gtags-dwim)
    (evil-define-key 'normal c++-mode-map (kbd "C-]") 'helm-gtags-dwim)

    (advice-add 'helm-gtags-dwim :before 'evil--jumps-push))
#+END_SRC

* Company

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :pin melpa-stable
    :defer t

    :init
    (add-hook 'c-mode-hook          'company-mode)
    (add-hook 'c++-mode-hook        'company-mode)
    (add-hook 'emacs-lisp-mode-hook 'company-mode)
    (add-hook 'cmake-mode-hook      'company-mode)
    :config
    (setq company-backends (delete 'company-semantic company-backends)) ;; Ensure semantic is not used by company.
    (setq company-dabbrev-downcase nil) ;; Do not downcase returned candidates.
    (setq company-dabbrev-ignore-case t) ;; Ignore case for completion.
    (setq company-dabbrev-code-ignore-case t) ;; Ignore case for completion.
    (setq company-async-timeout 10)
    (setq company-idle-delay nil))
#+END_SRC

* Helm company

#+BEGIN_SRC emacs-lisp
  (use-package helm-company
   :ensure t
   :after company

   :config
   (evil-define-key 'insert c-mode-map                (kbd "TAB") 'helm-company)
   (evil-define-key 'insert c++-mode-map              (kbd "TAB") 'helm-company)
   (evil-define-key 'insert emacs-lisp-mode-map       (kbd "TAB") 'helm-company)
   (evil-define-key 'insert lisp-interaction-mode-map (kbd "TAB") 'helm-company)
   (setq helm-company-fuzzy-match nil))
#+END_SRC

* Semantic

#+BEGIN_SRC emacs-lisp
  (use-package semantic
    :ensure t
    :defer t

    :init
    (add-hook 'c-mode-hook          'semantic-mode)
    (add-hook 'c++-mode-hook        'semantic-mode)
    (add-hook 'emacs-lisp-mode-hook 'semantic-mode)

    :config
    (global-semantic-stickyfunc-mode)

    (defun my-semantic-ia-fast-jump ()
      "Saves current position in evil jump list, then calls `semantic-ia-fast-jump'."
      (interactive)
      (evil--jumps-push)
      (semantic-ia-fast-jump (point)))

    (evil-define-key 'normal c++-mode-map (kbd "C-}") 'my-semantic-ia-fast-jump))
#+END_SRC

* Git for Windows path
Check if Git for Windows is installed when running on a Windows system. If so,
add the Git installation to ~exec-path~ and the PATH environment variable. This
way Emacs can use the various Unix tools (such as diff.exe for running Ediff and
gpg.exe for EasyPG) bundled with the Git installation.
#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'windows-nt)
    (let ((git-path "C:/Program Files/Git/usr/bin"))
      (when (file-exists-p git-path)
        (add-to-list 'exec-path git-path t)
        ;; Also trick the git programs to look in /usr/bin (useful when using diff3).
        (setenv "PATH" (concat (getenv "PATH") "/usr/bin;"))
        (setenv "PATH" (concat (getenv "PATH") git-path ";"))

        ;; Set the path to gpg.
        (use-package epg
          :custom
          (epg-gpg-program (concat git-path "/gpg"))))))

  (add-to-list 'auto-mode-alist '(".gitattributes" . conf-unix-mode))
  (add-to-list 'auto-mode-alist '(".git/config" . conf-unix-mode))
  (add-to-list 'auto-mode-alist '(".gitconfig" . conf-unix-mode))

#+END_SRC

* Ivy / Counsel / Swiper
I like helm, I like swiper. Combining the two makes me happy.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :defer t
    :ensure t
    :pin melpa-stable)

  (use-package swiper-helm
    :defer t
    :ensure t
    :pin melpa-stable)
#+END_SRC

* Dired-narrow
Dired-narrow is a nice package to do quick filtering in dired buffers.
#+BEGIN_SRC emacs-lisp
  (use-package dired-narrow
    :ensure t
    :bind (:map dired-mode-map
                ("/" . dired-narrow)))
#+END_SRC

* Hackernews
Emacs can do everything, so why not browse hackernews with it?
#+BEGIN_SRC emacs-lisp
  (use-package hackernews
    :pin melpa-stable
    :defer t
    :init
    (evil-set-initial-state 'hackernews-mode 'emacs))
#+END_SRC

* Rainbow-delimiters
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :pin melpa-stable
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC
