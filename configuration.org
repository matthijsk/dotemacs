#+TITLE: Emacs Configuration
#+OPTIONS: toc:nil

* Emacs settings
** Packages and use-package
This configuration file is loaded using ~(org-babel-load-file)~. To ensure
org-mode is properly initialized before loading this file ~package-archives~
settings and the call to ~(package-initialize)~ are done in =[[file:init.el][init.el]]=.

[[https://github.com/jwiegley/use-package][Use-package]] allows for automatic installation of packages, which is great when
you want to use Emacs on multiple systems. Also, it loads packages when needed,
keeping the Emacs startup time short.
#+BEGIN_SRC emacs-lisp
  (require 'use-package)
#+END_SRC

[[https://github.com/myrjola/diminish.el][Diminish]] can be used as part of =use-package= to hide minor mode strings from
the modeline.
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t)
#+END_SRC

** General settings
General Emacs settings relating to fonts, themes, keybindings, etc.

Display the scratch buffer when starting up.
#+BEGIN_SRC emacs-lisp
  (setq initial-buffer-choice t)
#+END_SRC

Start Emacs as server for emacsclient processes.
#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC

Allow for basic paging in emacs shells.
#+BEGIN_SRC emacs-lisp
  (setenv "PAGER" "/bin/cat")
#+END_SRC

Increase warning limit to 100 MB for large files.
#+BEGIN_SRC emacs-lisp
  (setq large-file-warning-threshold (* 100 1024 1024))
#+END_SRC

Fix slow redisplay when certain special characters are on screen.
#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

** Scrolling
Settings related to scrolling buffers. 

Provide some context by have the cursor offset from the top and the bottom of
the buffer by three lines.
#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 3)
#+END_SRC

Scroll by one line when reaching bottom of buffer instead of recentering the
buffer.
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively most-positive-fixnum)
#+END_SRC

Don't scroll faster when the mouse wheel is turned faster. Also, use a fixed
scroll amount of three lines.
#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-progressive-speed nil)
  (setq mouse-wheel-scroll-amount (quote (3 ((shift) . 1) ((control)))))
#+END_SRC

** User interface
Set the [[https://pawelbx.github.io/emacs-theme-gallery/screenshots/dark/wombat/el.png][wombat]] builtin theme. Pretty neat.
#+BEGIN_SRC emacs-lisp
  (load-theme 'wombat)
#+END_SRC

Disable the tool bar, the menu bar and the scroll bars.
#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (set-scroll-bar-mode nil)
#+END_SRC

Default to displaying line numbers as relative.
#+BEGIN_SRC emacs-lisp
  (setq display-line-numbers-type 'relative)
#+END_SRC

Display time as 24h.
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
#+END_SRC

Use a visible bell.
#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

Don't blink cursor
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
#+END_SRC

** Key bindings
Remap =C-x C-b= to ~ibuffer~ instead of the default.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

Reload ('revert') a buffer with =F5= without asking for confirmation, and
preserve all modes.
#+BEGIN_SRC emacs-lisp
  (defun my-revert-buffer ()
    "Revert a buffer without asking for confirmation and preserve all modes."
    (interactive)
    (revert-buffer nil t t))

  (global-set-key (kbd "<f5>") 'my-revert-buffer)
#+END_SRC

Load alternate file with =F6= (useful for switching .c and .h).
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f6>") 'ff-find-other-file)
#+END_SRC

Exhibit expected X clipboard behaviour (yank with middle mouse button).
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<mouse-2>") 'x-clipboard-yank)
  (setq-default x-select-enable-primary t)
#+END_SRC

Bind mouse buttons to Info-mode and help-mode navigation.
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'Info-mode
    '(progn (define-key Info-mode-map (kbd "<mouse-8>") 'Info-history-back)
            (define-key Info-mode-map (kbd "<mouse-9>") 'Info-history-forward)))

  (eval-after-load 'help-mode
    '(progn (define-key help-mode-map (kbd "<mouse-8>") 'help-go-back)
            (define-key help-mode-map (kbd "<mouse-9>") 'help-go-forward)))
#+END_SRC

Disable =C-h h=, which is bound to ~view-hello-file~. I sometimes press this
accidentally. As opening the HELLO file takes long enough to be annoying disable
this binding here.
#+BEGIN_SRC emacs-lisp
  (global-unset-key (kbd "C-h h"))
#+END_SRC

Some sane bindings for making and deleting frames (an Emacs 'frame' is a
'window' in modern terms). =C-x 5 2= and =C-x 5 0= are just...too much. So
instead use =C-c n= for a new frame and =C-c x= (and =M-<f4>=) to delete the
frame.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c n") 'make-frame-command) 

  (global-set-key (kbd "C-c x") 'delete-frame)
  (global-set-key (kbd "M-<f4>") 'delete-frame)
#+END_SRC

When I call kill-buffer I pretty much always mean to kill the current
buffer. The default functionality is to prompt for a buffer name. Instead, I
want the buffer to be killed immediately. Inspiration:
http://pragmaticemacs.com/emacs/dont-kill-buffer-kill-this-buffer-instead/.
#+BEGIN_SRC emacs-lisp
  (defun my-kill-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'my-kill-buffer)
#+END_SRC

** Enable disabled commands
Some commands are disabled by default, enable these so Emacs doesn't
ask for confirmation every time the command is executed.

Allow narrowing.
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

Allow upcasing and lowercasing of regions.
#+BEGIN_SRC emacs-lisp
  (put 'upcase-region   'disabled nil)
  (put 'downcase-region 'disabled nil)
#+END_SRC

** Programming settings
Settings for setting up a programming environment.

Enable eldoc-mode for elisp buffers.
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

Highlight matching parentheses.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

Customize comment-dwim so it does exactly what I want it to do:
- If a region is active comment it if not commented or uncomment if commented.
- Otherwise comment or uncomment the current line and move to the next line.
Seriously, Emacs is awesome. I love this kind of customization power.
#+BEGIN_SRC emacs-lisp
  (defun my-comment-dwim (arg)
    "Call the comment command you want (Do What I Mean).
  If the region is active and `transient-mark-mode' is on, call
  `comment-region' (unless it only consists of comments, in which
  case it calls `uncomment-region').  Else, it calls
  `comment-line'.  Custom implementation derived from
  `comment-dwim'. The diffence is that the original function
  appends a comment to a line while this functions comments the
  line itself."
    (interactive "*P")
    (comment-normalize-vars)
    (if (use-region-p)
        (comment-or-uncomment-region (region-beginning) (region-end) arg)
      (comment-line 1)))
#+END_SRC

Never indent with tabs.
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

Autoscroll compilation window and stop on first error.
#+BEGIN_SRC emacs-lisp
  (setq compilation-scroll-output 'first-error)
#+END_SRC

Set c indentation to 2.
#+BEGIN_SRC emacs-lisp
  (setq c-default-style "linux"
        c-basic-offset 2)
#+END_SRC

Set some modes for specific file types.
- Set ~xml-mode~ when loading =cbproj= and =groupproj= files.
- Set ~c++-mode~ when loading =.rc= and =.rh= files.
- Set ~c++-mode~ when loading =.h= files. All I do is c++ all day.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.cbproj\\'" . xml-mode))
  (add-to-list 'auto-mode-alist '("\\.groupproj\\'" . xml-mode))

  (add-to-list 'auto-mode-alist '("\\.rh\\'" . c++-mode))
  (add-to-list 'auto-mode-alist '("\\.rc\\'" . c++-mode))

  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+END_SRC

** Default search function
Just a wrapper around whatever search function strikes my fancy
today. This makes it easier to change functionality without the tedium
of having to rebind all keys.
#+BEGIN_SRC emacs-lisp
  (defun my-search ()
    (interactive)
    (swiper-helm (word-at-point)))
    ;; (swiper))
    ;; (helm-occur))
    ;; (helm-swoop))
#+END_SRC

** Find configuration files
#+BEGIN_SRC emacs-lisp
  (defun my-find-configuration-file ()
    "Opens the configuration file in a new buffer.
  Opens the configuration file that is loaded by
  `user-init-file'. Use `my-find-init-file' to open
  `user-init-file'."
    (interactive)
    (find-file (concat user-emacs-directory "configuration.org")))

  (defun my-find-init-file ()
    "Opens `user-init-file' in a new buffer."
    (interactive)
    (find-file user-init-file))
#+END_SRC

* Smart mode line
Use [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] as a mode-line. Nothing too fancy but offers more
than the default.
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :ensure t
    :config
    (setq sml/theme 'automatic)
    (sml/setup))
#+END_SRC

* Default text scale

#+BEGIN_SRC emacs-lisp

  ;; START DEFAULT-TEXT-SCALE
  ;; Allow scaling of all buffers.
  (use-package default-text-scale
    :ensure t
    :bind (("C-M-="       . default-text-scale-increase)
           ("C-<mouse-4>" . default-text-scale-increase)
           ("C-M--"       . default-text-scale-decrease)
           ("C-<mouse-5>" . default-text-scale-decrease)))

#+END_SRC

* Helm

#+BEGIN_SRC emacs-lisp

  (use-package helm
    :diminish helm-mode
    :ensure t
    :bind (("M-x"     . helm-M-x)
           ("C-x b"   . helm-mini)
           ("<C-tab>" . helm-mini)
           ("C-x C-f" . helm-find-files)
           ("C-x C-h" . helm-resume-existing)
           ("C-s"     . my-search)
           ("C-x r l" . helm-bookmarks)
           :map helm-map
           ;; Use <C-tab> and <C-S-tab> to navigate helm buffers.
           ("<C-tab>"   . helm-next-line)
           ("<C-S-tab>" . helm-previous-line))

    :config
    (defun helm-resume-existing ()
      "Resume previous helm session with prefix to choose among existing helm buffers."
      (interactive)
      (helm-resume t))

    (helm-mode 1)

    (defun my-setup-eshell-completion ()
      "Setup helm completion for use with eshell."
      (eshell-cmpl-initialize)
      (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)
      (define-key eshell-mode-map (kbd "M-p") 'helm-eshell-history))
  
    (add-hook 'eshell-mode-hook 'my-setup-eshell-completion)

    ;; :custom
    (setq helm-buffer-max-length nil)
    (setq helm-split-window-inside-p t))

#+END_SRC

* Projectile

#+BEGIN_SRC emacs-lisp

  (use-package projectile
    :ensure t
    :bind-keymap ("C-c p" . projectile-command-map)
    :bind (:map projectile-mode-map
                ("<f9>" . projectile-run-project)
                ("C-<f9>" . projectile-compile-project)
                ("M-<f9>" . projectile-test-project))
    :init
    (add-hook 'c-mode-hook     'projectile-mode)
    (add-hook 'c++-mode-hook   'projectile-mode)
    (add-hook 'cmake-mode-hook 'projectile-mode)

    :config
    (projectile-global-mode)

    ;; :custom
    (setq projectile-indexing-method 'alien)
    (setq projectile-enable-caching t)
    (setq projectile-use-git-grep t))

#+END_SRC

* Helm-projectile

#+BEGIN_SRC emacs-lisp

  (use-package helm-projectile
    :ensure t
    :after projectile
    :init
    (setq helm-projectile-fuzzy-match nil)
    (setq projectile-switch-project-action 'helm-projectile)
    :config
    (helm-projectile-on))

#+END_SRC

* Evil

#+BEGIN_SRC emacs-lisp

  (use-package evil
    :ensure t
    :demand t
    :diminish undo-tree-mode
    :bind (:map evil-normal-state-map
                ("C-s"   . save-buffer)
                ("C-/"   . my-comment-dwim)
                ("C-f"   . my-search)
                ("<SPC>" . helm-mini)

           :map evil-motion-state-map
                ("C-f" . my-search)

           :map evil-insert-state-map
                ("C-s" . save-buffer)
           )
    :init
    (setq evil-want-C-u-scroll t)
    (setq evil-symbol-word-search t)
    (setq evil-shift-width 2)

    :config
    (evil-define-key 'motion Man-mode-map (kbd "RET") 'man-follow)

    ;; Jump to tag and recenter
    (advice-add 'evil-jump-to-tag     :after 'evil-scroll-line-to-center)
    (advice-add 'evil-jump-backward   :after 'evil-scroll-line-to-center)
    (advice-add 'evil-jump-forward    :after 'evil-scroll-line-to-center)
    (advice-add 'evil-search-next     :after 'evil-scroll-line-to-center)
    (advice-add 'evil-search-previous :after 'evil-scroll-line-to-center)

    ;; Ex commands.
    (evil-ex-define-cmd "A"  'ff-find-other-file)
    (evil-ex-define-cmd "ls" 'ibuffer)
    (evil-ex-define-cmd "e"  'helm-find-files)

    ;; Set evil mode when in these modes.
    (add-hook 'with-editor-mode-hook 'evil-normal-state)

    ;; Ensure Emacs bindings for RET and SPC are available in motion state.
    ;; https://www.emacswiki.org/emacs/Evil#toc12
    (defun my-move-key (keymap-from keymap-to key)
      "Moves key binding from one keymap to another, deleting from the old location. "
      (define-key keymap-to key (lookup-key keymap-from key))
      (define-key keymap-from key nil))
    (my-move-key evil-motion-state-map evil-normal-state-map (kbd "RET"))
    (my-move-key evil-motion-state-map evil-normal-state-map " ")

    ;; Set custom evil state when in these modes.
    (evil-set-initial-state 'eshell-mode          'emacs)
    (evil-set-initial-state 'magit-staging-mode   'emacs)
    (evil-set-initial-state 'image-mode           'emacs)
    (evil-set-initial-state 'messages-buffer-mode 'motion)
    (evil-set-initial-state 'eww-mode             'motion)
    (evil-set-initial-state 'eww-buffers-mode     'motion)
    (evil-set-initial-state 'hackernews-mode      'motion))

#+END_SRC

* Evil-leader

#+BEGIN_SRC emacs-lisp

  (use-package evil-leader
    :ensure t
    :after evil
    :config
    (evil-leader/set-leader ",")
    (evil-leader/set-key "e"   'my-find-configuration-file
                         "i"   'my-find-init-file

                          "sh"  'eshell

                          "wc"  'evil-window-delete
                          "x0"  'delete-window

                          "ww"  'evil-window-next
                          "xo"  'other-window

                          "wo"  'delete-other-windows
                          "x1"  'delete-other-windows

                          "ws"  'evil-window-split
                          "x2"  'split-window-below

                          "wv"  'evil-window-vsplit
                          "x3"  'split-window-right

                          "wh"  'evil-window-left
                          "wj"  'evil-window-down
                          "wk"  'evil-window-up
                          "wl"  'evil-window-right

                          "xk"  'my-kill-buffer
                          "rb"  'revert-buffer
                          "x#"  'server-edit
                          "n"   'server-edit
                          "xc"  'save-buffers-kill-terminal

                          "b"   'helm-mini
                          "xf"  'helm-find-files
                          "hb"  'helm-bookmarks
                          "hs"  'helm-semantic
                          "xh"  'helm-resume-existing

                          "l"   'whitespace-mode
                          "hl"  'hl-line-mode
                          "rl"  'display-line-numbers-mode

                          "m"   'compile
                          "c"   'compile

                          "pp"  'projectile-test-project

                          "pf"  'helm-projectile-find-file
                          "psg" 'helm-projectile-grep
                          "pa"  'helm-projectile-find-other-file)

    (evil-leader/set-key-for-mode 'org-mode "hs" 'helm-org-in-buffer-headings)

    ;; Enable evil leader.
    (global-evil-leader-mode)

    ;; Start evil.
    (evil-mode))

#+END_SRC

* Org mode

#+BEGIN_SRC emacs-lisp

  ;; Org html export requires htmlize
  (use-package htmlize
    :ensure t
    :defer t)

  (use-package org
    ;; Global key bindings.
    :bind (("\C-cl" . org-store-link)
           ("\C-ca" . org-agenda)
           ("\C-cc" . org-capture)
           ("\C-cb" . org-switchb)
           ("\C-ci" . clock-in)
           ("\C-co" . org-clock-out))
    :init
    (setq org-todo-keywords
          '((sequence "TODO" "IN PROGRESS" "REVIEW" "DONE" )))

    :config
    (defun iso-week-number ()
      "Returns the ISO week number for today."
      (org-days-to-iso-week (org-today)))

    (defun clock-in-monday ()
      "Creates a new \"Week <WEEK-NUMBER>\" heading."
      (interactive)
      (if (not (org-at-heading-p))
          (user-error "Not at a heading"))
      (beginning-of-line)
      (org-insert-heading)
      (insert (format "Week %s" (iso-week-number)))
      (clock-in t))

    (defun clock-in (&optional monday)
      "Clock in with org mode."
      (interactive)
      (if (not (org-at-heading-p))
          (user-error "Not at a heading"))
      (org-insert-heading-after-current)
      (org-insert-time-stamp (current-time) nil t)
      (if monday
          (org-demote))
      (org-clock-in)
      (org-insert-heading-after-current)
      (org-demote)
      (insert " Standup")
      (forward-line)
      ;; Create table "| todo | in progress | done |"
      (org-table-create "3x2")
      (org-table-put 1 1 "todo")
      (org-table-put 1 2 "in progress")
      (org-table-put 1 3 "done" t)) ;; set align to auto align table

    (org-clock-persistence-insinuate)

    ;; Org mode babel language support.
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (shell . t)
       (C . t)))

    ;; Do not interpret "_" and "^" for sub and superscript when
    ;; exporting.
    (setq org-export-with-sub-superscripts nil)

    ;; When in org-mode, use expected org-mode tab behaviour when in
    ;; Normal and Insert state. Set jump keys to navigate org links and
    ;; the mark ring.
    (evil-define-key 'normal org-mode-map
      [tab] 'org-cycle
      (kbd "C-]") 'org-open-at-point
      (kbd "C-o") 'org-mark-ring-goto)

    (evil-define-key 'insert org-mode-map [tab] 'org-cycle)

    ;; :custom
    (setq org-outline-path-complete-in-steps nil)

    ;; Save the running clock when Emacs exits.
    (setq org-clock-persist 'clock)

    ;; Flushright tags to column 100.
    (setq org-tags-column -100))

#+END_SRC

* Magit

#+BEGIN_SRC emacs-lisp

  (use-package magit
    :ensure t
    :defer t
    :bind (:map evil-leader--default-map
                ("st" . magit-staging)
                ("f"  . magit-file-popup))
    :init
    (setq vc-handled-backends nil)

    :config
    ;; Don't show tags when displaying refs
    (remove-hook 'magit-refs-sections-hook 'magit-insert-tags)

    ;; Don't show diff when committing (use C-c C-d to show diff anyway)
    (remove-hook 'server-switch-hook 'magit-commit-diff)

    ;; Improve staging performance on windows
    ;; See https://github.com/magit/magit/issues/2395
    (define-derived-mode magit-staging-mode magit-status-mode "Magit staging"
      "Mode for showing staged and unstaged changes."
      :group 'magit-status)

    (defun magit-staging-refresh-buffer ()
      (magit-insert-section (status)
                            (magit-insert-untracked-files)
                            (magit-insert-unstaged-changes)
                            (magit-insert-staged-changes)))

    (defun magit-staging ()
      (interactive)
      (magit-mode-setup #'magit-staging-mode))

    (magit-define-popup-switch 'magit-log-popup ?f "first parent" "--first-parent")

    (evil-define-key 'normal magit-blame-mode-map (kbd "q") 'magit-blame-quit)

    ;; :custom
    (setq magit-refresh-verbose t))

#+END_SRC

* CMake mode

#+BEGIN_SRC emacs-lisp

  (use-package cmake-mode
    :ensure t
    :defer t)

#+END_SRC

* Ninja mode

#+BEGIN_SRC emacs-lisp

  (use-package ninja-mode
    :ensure t
    :defer t)

#+END_SRC

* GTAGS / GNU Global

#+BEGIN_SRC emacs-lisp

  ;; Force treating of .h files as C++ source
  (setenv "GTAGSFORCECPP" "true")

#+END_SRC

* Helm gtags

#+BEGIN_SRC emacs-lisp

  (use-package helm-gtags
    :ensure t
    :defer t
    :init
    (add-hook 'c-mode-hook   'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    ;; :custom
    :config
    (setq helm-gtags-path-style 'absolute)
    (setq helm-gtags-use-input-at-cursor t)
    (setq helm-gtags-auto-update t)
    (setq helm-gtags-pulse-at-cursor t)
    :config
    (evil-define-key 'normal c-mode-map   (kbd "C-]") 'helm-gtags-dwim)
    (evil-define-key 'normal c++-mode-map (kbd "C-]") 'helm-gtags-dwim)
    (evil-define-key 'normal c++-mode-map (kbd "C-o") 'helm-gtags-pop-stack))

#+END_SRC

* Company

#+BEGIN_SRC emacs-lisp

  (use-package company
    :ensure t
    :defer t
    :init
    (add-hook 'c-mode-hook          'company-mode)
    (add-hook 'c++-mode-hook        'company-mode)
    (add-hook 'emacs-lisp-mode-hook 'company-mode)
    (add-hook 'cmake-mode-hook      'company-mode)
    :config
    (setq company-dabbrev-downcase nil) ;; Do not downcase returned candidates.
    (setq company-dabbrev-ignore-case t) ;; Ignore case for completion
    (setq company-dabbrev-code-ignore-case t) ;; Ignore case for completion
    (setq company-async-timeout 10)
    ;; :custom
    (setq company-idle-delay nil))

#+END_SRC

* Helm company

#+BEGIN_SRC emacs-lisp

  (use-package helm-company
    :ensure t
    :bind (:map evil-insert-state-map
                ([tab] . helm-company))
    ;; :custom
    :config
    (setq helm-company-fuzzy-match nil))

#+END_SRC

* Semantic

#+BEGIN_SRC emacs-lisp

  (use-package semantic
    :ensure t
    :defer t
    :init
    (add-hook 'c-mode-hook   'semantic-mode)
    (add-hook 'c++-mode-hook 'semantic-mode)
    ;; :custom
    :config
    ;; Ensure semantic is not used by company
    (setq company-backends (delete 'company-semantic company-backends))
    (global-semantic-stickyfunc-mode)
    (evil-define-key 'normal c++-mode-map (kbd "C-}") 'semantic-ia-fast-jump))

#+END_SRC

* Ivy / Counsel / Swiper
I like helm, I like swiper. Combining the two makes me happy.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t)

  (use-package swiper-helm
    :ensure t)
#+END_SRC

* Dired-narrow
#+BEGIN_SRC emacs-lisp
  (use-package dired-narrow
    :ensure t
    :bind (:map dired-mode-map
                ("/" . dired-narrow)))
#+END_SRC

* Helpful
#+BEGIN_SRC emacs-lisp
  ;; Note that the built-in `describe-function' includes both functions
  ;; and macros. `helpful-function' is functions only, so we provide
  ;; `helpful-callable' as a drop-in replacement.
  (use-package helpful
    :ensure t
    :bind (("C-h f" . helpful-callable)
           ("C-h v" . helpful-variable)
           ("C-h k" . helpful-key)))
#+END_SRC
